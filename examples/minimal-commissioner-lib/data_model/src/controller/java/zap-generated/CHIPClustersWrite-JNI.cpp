/*
 *
 *    Copyright (c) 2022 Project CHIP Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

// THIS FILE IS GENERATED BY ZAP
#include "CHIPCallbackTypes.h"
#include "CHIPInvokeCallbacks.h"
#include "CHIPReadCallbacks.h"

#include <app-common/zap-generated/cluster-objects.h>
#include <zap-generated/CHIPClientCallbacks.h>
#include <zap-generated/CHIPClusters.h>

#include <controller/java/AndroidCallbacks.h>
#include <controller/java/AndroidClusterExceptions.h>
#include <controller/java/CHIPDefaultCallbacks.h>
#include <jni.h>
#include <lib/support/CHIPListUtils.h>
#include <lib/support/CodeUtils.h>
#include <lib/support/JniReferences.h>
#include <lib/support/JniTypeWrappers.h>
#include <lib/support/Span.h>
#include <platform/PlatformManager.h>
#include <vector>

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wshorten-64-to-32"

#define JNI_METHOD(RETURN, CLASS_NAME, METHOD_NAME)                                                                                \
    extern "C" JNIEXPORT RETURN JNICALL Java_chip_devicecontroller_ChipClusters_00024##CLASS_NAME##_##METHOD_NAME

using namespace chip;
using namespace chip::Controller;

JNI_METHOD(void, IdentifyCluster, writeIdentifyTimeAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    ListFreer listFreer;
    using TypeInfo = chip::app::Clusters::Identify::Attributes::IdentifyTime::TypeInfo;
    TypeInfo::Type cppValue;

    std::vector<Platform::UniquePtr<JniByteArray>> cleanupByteArrays;
    std::vector<Platform::UniquePtr<JniUtfString>> cleanupStrings;

    cppValue =
        static_cast<std::remove_reference_t<decltype(cppValue)>>(chip::JniReferences::GetInstance().IntegerToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err               = CHIP_NO_ERROR;
    IdentifyCluster * cppCluster = reinterpret_cast<IdentifyCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, AccessControlCluster, writeAclAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    ListFreer listFreer;
    using TypeInfo = chip::app::Clusters::AccessControl::Attributes::Acl::TypeInfo;
    TypeInfo::Type cppValue;

    std::vector<Platform::UniquePtr<JniByteArray>> cleanupByteArrays;
    std::vector<Platform::UniquePtr<JniUtfString>> cleanupStrings;

    {
        using ListType_0       = std::remove_reference_t<decltype(cppValue)>;
        using ListMemberType_0 = ListMemberTypeGetter<ListType_0>::Type;
        jint valueSize;
        chip::JniReferences::GetInstance().GetListSize(value, valueSize);
        if (valueSize != 0)
        {
            auto * listHolder_0 = new ListHolder<ListMemberType_0>(valueSize);
            listFreer.add(listHolder_0);

            for (jint i_0 = 0; i_0 < valueSize; ++i_0)
            {
                jobject element_0;
                chip::JniReferences::GetInstance().GetListItem(value, i_0, element_0);
                jobject element_0_privilegeItem_1;
                chip::JniReferences::GetInstance().GetObjectField(element_0, "privilege", "Ljava/lang/Integer;",
                                                                  element_0_privilegeItem_1);
                listHolder_0->mList[i_0].privilege =
                    static_cast<std::remove_reference_t<decltype(listHolder_0->mList[i_0].privilege)>>(
                        chip::JniReferences::GetInstance().IntegerToPrimitive(element_0_privilegeItem_1));
                jobject element_0_authModeItem_1;
                chip::JniReferences::GetInstance().GetObjectField(element_0, "authMode", "Ljava/lang/Integer;",
                                                                  element_0_authModeItem_1);
                listHolder_0->mList[i_0].authMode =
                    static_cast<std::remove_reference_t<decltype(listHolder_0->mList[i_0].authMode)>>(
                        chip::JniReferences::GetInstance().IntegerToPrimitive(element_0_authModeItem_1));
                jobject element_0_subjectsItem_1;
                chip::JniReferences::GetInstance().GetObjectField(element_0, "subjects", "Ljava/util/ArrayList;",
                                                                  element_0_subjectsItem_1);
                if (element_0_subjectsItem_1 == nullptr)
                {
                    listHolder_0->mList[i_0].subjects.SetNull();
                }
                else
                {
                    auto & nonNullValue_2 = listHolder_0->mList[i_0].subjects.SetNonNull();
                    {
                        using ListType_3       = std::remove_reference_t<decltype(nonNullValue_2)>;
                        using ListMemberType_3 = ListMemberTypeGetter<ListType_3>::Type;
                        jint element_0_subjectsItem_1Size;
                        chip::JniReferences::GetInstance().GetListSize(element_0_subjectsItem_1, element_0_subjectsItem_1Size);
                        if (element_0_subjectsItem_1Size != 0)
                        {
                            auto * listHolder_3 = new ListHolder<ListMemberType_3>(element_0_subjectsItem_1Size);
                            listFreer.add(listHolder_3);

                            for (jint i_3 = 0; i_3 < element_0_subjectsItem_1Size; ++i_3)
                            {
                                jobject element_3;
                                chip::JniReferences::GetInstance().GetListItem(element_0_subjectsItem_1, i_3, element_3);
                                listHolder_3->mList[i_3] = static_cast<std::remove_reference_t<decltype(listHolder_3->mList[i_3])>>(
                                    chip::JniReferences::GetInstance().LongToPrimitive(element_3));
                            }
                            nonNullValue_2 = ListType_3(listHolder_3->mList, element_0_subjectsItem_1Size);
                        }
                        else
                        {
                            nonNullValue_2 = ListType_3();
                        }
                    }
                }
                jobject element_0_targetsItem_1;
                chip::JniReferences::GetInstance().GetObjectField(element_0, "targets", "Ljava/util/ArrayList;",
                                                                  element_0_targetsItem_1);
                if (element_0_targetsItem_1 == nullptr)
                {
                    listHolder_0->mList[i_0].targets.SetNull();
                }
                else
                {
                    auto & nonNullValue_2 = listHolder_0->mList[i_0].targets.SetNonNull();
                    {
                        using ListType_3       = std::remove_reference_t<decltype(nonNullValue_2)>;
                        using ListMemberType_3 = ListMemberTypeGetter<ListType_3>::Type;
                        jint element_0_targetsItem_1Size;
                        chip::JniReferences::GetInstance().GetListSize(element_0_targetsItem_1, element_0_targetsItem_1Size);
                        if (element_0_targetsItem_1Size != 0)
                        {
                            auto * listHolder_3 = new ListHolder<ListMemberType_3>(element_0_targetsItem_1Size);
                            listFreer.add(listHolder_3);

                            for (jint i_3 = 0; i_3 < element_0_targetsItem_1Size; ++i_3)
                            {
                                jobject element_3;
                                chip::JniReferences::GetInstance().GetListItem(element_0_targetsItem_1, i_3, element_3);
                                jobject element_3_clusterItem_4;
                                chip::JniReferences::GetInstance().GetObjectField(element_3, "cluster", "Ljava/lang/Long;",
                                                                                  element_3_clusterItem_4);
                                if (element_3_clusterItem_4 == nullptr)
                                {
                                    listHolder_3->mList[i_3].cluster.SetNull();
                                }
                                else
                                {
                                    auto & nonNullValue_5 = listHolder_3->mList[i_3].cluster.SetNonNull();
                                    nonNullValue_5        = static_cast<std::remove_reference_t<decltype(nonNullValue_5)>>(
                                        chip::JniReferences::GetInstance().LongToPrimitive(element_3_clusterItem_4));
                                }
                                jobject element_3_endpointItem_4;
                                chip::JniReferences::GetInstance().GetObjectField(element_3, "endpoint", "Ljava/lang/Integer;",
                                                                                  element_3_endpointItem_4);
                                if (element_3_endpointItem_4 == nullptr)
                                {
                                    listHolder_3->mList[i_3].endpoint.SetNull();
                                }
                                else
                                {
                                    auto & nonNullValue_5 = listHolder_3->mList[i_3].endpoint.SetNonNull();
                                    nonNullValue_5        = static_cast<std::remove_reference_t<decltype(nonNullValue_5)>>(
                                        chip::JniReferences::GetInstance().IntegerToPrimitive(element_3_endpointItem_4));
                                }
                                jobject element_3_deviceTypeItem_4;
                                chip::JniReferences::GetInstance().GetObjectField(element_3, "deviceType", "Ljava/lang/Long;",
                                                                                  element_3_deviceTypeItem_4);
                                if (element_3_deviceTypeItem_4 == nullptr)
                                {
                                    listHolder_3->mList[i_3].deviceType.SetNull();
                                }
                                else
                                {
                                    auto & nonNullValue_5 = listHolder_3->mList[i_3].deviceType.SetNonNull();
                                    nonNullValue_5        = static_cast<std::remove_reference_t<decltype(nonNullValue_5)>>(
                                        chip::JniReferences::GetInstance().LongToPrimitive(element_3_deviceTypeItem_4));
                                }
                            }
                            nonNullValue_2 = ListType_3(listHolder_3->mList, element_0_targetsItem_1Size);
                        }
                        else
                        {
                            nonNullValue_2 = ListType_3();
                        }
                    }
                }
                jobject element_0_fabricIndexItem_1;
                chip::JniReferences::GetInstance().GetObjectField(element_0, "fabricIndex", "Ljava/lang/Integer;",
                                                                  element_0_fabricIndexItem_1);
                listHolder_0->mList[i_0].fabricIndex =
                    static_cast<std::remove_reference_t<decltype(listHolder_0->mList[i_0].fabricIndex)>>(
                        chip::JniReferences::GetInstance().IntegerToPrimitive(element_0_fabricIndexItem_1));
            }
            cppValue = ListType_0(listHolder_0->mList, valueSize);
        }
        else
        {
            cppValue = ListType_0();
        }
    }

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                    = CHIP_NO_ERROR;
    AccessControlCluster * cppCluster = reinterpret_cast<AccessControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, AccessControlCluster, writeExtensionAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    ListFreer listFreer;
    using TypeInfo = chip::app::Clusters::AccessControl::Attributes::Extension::TypeInfo;
    TypeInfo::Type cppValue;

    std::vector<Platform::UniquePtr<JniByteArray>> cleanupByteArrays;
    std::vector<Platform::UniquePtr<JniUtfString>> cleanupStrings;

    {
        using ListType_0       = std::remove_reference_t<decltype(cppValue)>;
        using ListMemberType_0 = ListMemberTypeGetter<ListType_0>::Type;
        jint valueSize;
        chip::JniReferences::GetInstance().GetListSize(value, valueSize);
        if (valueSize != 0)
        {
            auto * listHolder_0 = new ListHolder<ListMemberType_0>(valueSize);
            listFreer.add(listHolder_0);

            for (jint i_0 = 0; i_0 < valueSize; ++i_0)
            {
                jobject element_0;
                chip::JniReferences::GetInstance().GetListItem(value, i_0, element_0);
                jobject element_0_dataItem_1;
                chip::JniReferences::GetInstance().GetObjectField(element_0, "data", "[B", element_0_dataItem_1);
                cleanupByteArrays.push_back(
                    chip::Platform::MakeUnique<chip::JniByteArray>(env, static_cast<jbyteArray>(element_0_dataItem_1)));
                listHolder_0->mList[i_0].data = cleanupByteArrays.back()->byteSpan();
                jobject element_0_fabricIndexItem_1;
                chip::JniReferences::GetInstance().GetObjectField(element_0, "fabricIndex", "Ljava/lang/Integer;",
                                                                  element_0_fabricIndexItem_1);
                listHolder_0->mList[i_0].fabricIndex =
                    static_cast<std::remove_reference_t<decltype(listHolder_0->mList[i_0].fabricIndex)>>(
                        chip::JniReferences::GetInstance().IntegerToPrimitive(element_0_fabricIndexItem_1));
            }
            cppValue = ListType_0(listHolder_0->mList, valueSize);
        }
        else
        {
            cppValue = ListType_0();
        }
    }

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                    = CHIP_NO_ERROR;
    AccessControlCluster * cppCluster = reinterpret_cast<AccessControlCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, BasicInformationCluster, writeNodeLabelAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    ListFreer listFreer;
    using TypeInfo = chip::app::Clusters::BasicInformation::Attributes::NodeLabel::TypeInfo;
    TypeInfo::Type cppValue;

    std::vector<Platform::UniquePtr<JniByteArray>> cleanupByteArrays;
    std::vector<Platform::UniquePtr<JniUtfString>> cleanupStrings;

    cleanupStrings.push_back(chip::Platform::MakeUnique<chip::JniUtfString>(env, static_cast<jstring>(value)));
    cppValue = cleanupStrings.back()->charSpan();

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    BasicInformationCluster * cppCluster = reinterpret_cast<BasicInformationCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, BasicInformationCluster, writeLocationAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    ListFreer listFreer;
    using TypeInfo = chip::app::Clusters::BasicInformation::Attributes::Location::TypeInfo;
    TypeInfo::Type cppValue;

    std::vector<Platform::UniquePtr<JniByteArray>> cleanupByteArrays;
    std::vector<Platform::UniquePtr<JniUtfString>> cleanupStrings;

    cleanupStrings.push_back(chip::Platform::MakeUnique<chip::JniUtfString>(env, static_cast<jstring>(value)));
    cppValue = cleanupStrings.back()->charSpan();

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    BasicInformationCluster * cppCluster = reinterpret_cast<BasicInformationCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, BasicInformationCluster, writeLocalConfigDisabledAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    ListFreer listFreer;
    using TypeInfo = chip::app::Clusters::BasicInformation::Attributes::LocalConfigDisabled::TypeInfo;
    TypeInfo::Type cppValue;

    std::vector<Platform::UniquePtr<JniByteArray>> cleanupByteArrays;
    std::vector<Platform::UniquePtr<JniUtfString>> cleanupStrings;

    cppValue =
        static_cast<std::remove_reference_t<decltype(cppValue)>>(chip::JniReferences::GetInstance().BooleanToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                       = CHIP_NO_ERROR;
    BasicInformationCluster * cppCluster = reinterpret_cast<BasicInformationCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, LocalizationConfigurationCluster, writeActiveLocaleAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jstring value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    ListFreer listFreer;
    using TypeInfo = chip::app::Clusters::LocalizationConfiguration::Attributes::ActiveLocale::TypeInfo;
    TypeInfo::Type cppValue;

    std::vector<Platform::UniquePtr<JniByteArray>> cleanupByteArrays;
    std::vector<Platform::UniquePtr<JniUtfString>> cleanupStrings;

    cleanupStrings.push_back(chip::Platform::MakeUnique<chip::JniUtfString>(env, static_cast<jstring>(value)));
    cppValue = cleanupStrings.back()->charSpan();

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                                = CHIP_NO_ERROR;
    LocalizationConfigurationCluster * cppCluster = reinterpret_cast<LocalizationConfigurationCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, GeneralCommissioningCluster, writeBreadcrumbAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    ListFreer listFreer;
    using TypeInfo = chip::app::Clusters::GeneralCommissioning::Attributes::Breadcrumb::TypeInfo;
    TypeInfo::Type cppValue;

    std::vector<Platform::UniquePtr<JniByteArray>> cleanupByteArrays;
    std::vector<Platform::UniquePtr<JniUtfString>> cleanupStrings;

    cppValue = static_cast<std::remove_reference_t<decltype(cppValue)>>(chip::JniReferences::GetInstance().LongToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                           = CHIP_NO_ERROR;
    GeneralCommissioningCluster * cppCluster = reinterpret_cast<GeneralCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

JNI_METHOD(void, NetworkCommissioningCluster, writeInterfaceEnabledAttribute)
(JNIEnv * env, jobject self, jlong clusterPtr, jobject callback, jobject value, jobject timedWriteTimeoutMs)
{
    chip::DeviceLayer::StackLock lock;
    ListFreer listFreer;
    using TypeInfo = chip::app::Clusters::NetworkCommissioning::Attributes::InterfaceEnabled::TypeInfo;
    TypeInfo::Type cppValue;

    std::vector<Platform::UniquePtr<JniByteArray>> cleanupByteArrays;
    std::vector<Platform::UniquePtr<JniUtfString>> cleanupStrings;

    cppValue =
        static_cast<std::remove_reference_t<decltype(cppValue)>>(chip::JniReferences::GetInstance().BooleanToPrimitive(value));

    std::unique_ptr<CHIPDefaultSuccessCallback, void (*)(CHIPDefaultSuccessCallback *)> onSuccess(
        Platform::New<CHIPDefaultSuccessCallback>(callback), Platform::Delete<CHIPDefaultSuccessCallback>);
    VerifyOrReturn(onSuccess.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native success callback", CHIP_ERROR_NO_MEMORY));

    std::unique_ptr<CHIPDefaultFailureCallback, void (*)(CHIPDefaultFailureCallback *)> onFailure(
        Platform::New<CHIPDefaultFailureCallback>(callback), Platform::Delete<CHIPDefaultFailureCallback>);
    VerifyOrReturn(onFailure.get() != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Error creating native failure callback", CHIP_ERROR_NO_MEMORY));

    CHIP_ERROR err                           = CHIP_NO_ERROR;
    NetworkCommissioningCluster * cppCluster = reinterpret_cast<NetworkCommissioningCluster *>(clusterPtr);
    VerifyOrReturn(cppCluster != nullptr,
                   chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(
                       env, callback, "Could not get native cluster", CHIP_ERROR_INCORRECT_STATE));

    auto successFn = chip::Callback::Callback<CHIPDefaultWriteSuccessCallbackType>::FromCancelable(onSuccess->Cancel());
    auto failureFn = chip::Callback::Callback<CHIPDefaultFailureCallbackType>::FromCancelable(onFailure->Cancel());

    if (timedWriteTimeoutMs == nullptr)
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall);
    }
    else
    {
        err = cppCluster->WriteAttribute<TypeInfo>(cppValue, onSuccess->mContext, successFn->mCall, failureFn->mCall,
                                                   chip::JniReferences::GetInstance().IntegerToPrimitive(timedWriteTimeoutMs));
    }
    VerifyOrReturn(
        err == CHIP_NO_ERROR,
        chip::AndroidClusterExceptions::GetInstance().ReturnIllegalStateException(env, callback, "Error writing attribute", err));

    onSuccess.release();
    onFailure.release();
}

#pragma clang diagnostic pop
